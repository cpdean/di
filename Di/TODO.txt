
TODO
====

Implement the InsertKey command.

    The problem is figuring out which key was pressed in order to generate the command.

    The correct key can be found in the parser: whatever the current key in the current
    unparsed command is (based on index i) (at the time when the command object is created),
    that is the right key to insert.

    We can't make the parser static because it exists for a particular buffer.

    Aha!

    The InsertKey command, like all commands, has its own unique class. So this can be
    implemented as a special case in the key input handler: check if the bound command
    is InsertKey, in which case cast it and give it the current key.

Use a block cursor in command mode. Accomplish this by two steps:

    1. Change the color of the normal cursor to match the background
    2. Change the foreground and background colors of the character after the cursor
       so it appears that the block cursor is there.

Make keybindings configurable

    In the model, map keybindings to command names as strings.

    Add an attribute to each command class that specifies its name as a string.

    At startup, use reflection on our assembly to find all implementors of
    ICommand which have the name attribute, and add them to a lookup table.

    Eventually, there will be a configuration option allowing other assemblies
    containing commands to be loaded dynamically and searched for commands.
